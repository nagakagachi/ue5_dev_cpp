// PrePostProcessToon.usf

#include "/Engine/Private/Common.ush"

#if !defined(SHADER_ENTRY_POINT_MODE)
#define SHADER_ENTRY_POINT_MODE 0
#endif

float SampleRandom(float2 st) {
	return frac(sin(dot(st.xy,
						 float2(12.9898,78.233)))*43758.5453123);
}
float2 SampleRandomFloat2Float2(float2 st) {
	const float r0 = frac(sin(dot(st.xy, float2(12.9898,78.233)))*43758.5453123);
	const float r1 = frac(sin(dot(st.xy, float2(120.9898,7.233)))*43758.5453123);
	return float2(r0, r1);
}


#if 0 == SHADER_ENTRY_POINT_MODE

	Texture2D SourceTexture;
	Texture2D VoronoiWorkTexture;
	uint2 SourceDimensions;
	SamplerState SourceSampler;

	RWTexture2D<float4> OutputTexture;
	uint2 OutputDimensions;

	uint VisualizeMode;

	[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
	void MainCS(
		uint3 Gid	: SV_GroupID,
		uint3 DTid	: SV_DispatchThreadID,
		uint3 GTid	: SV_GroupThreadID,
		uint Gi		: SV_GroupIndex
		)
	{
		const float2 pixel_pos = DTid.xy + float2(0.5, 0.5);
		float3 voronoi_value = VoronoiWorkTexture.Load(uint3(DTid.xy, 0)).xyz;
		float4 source_color = SourceTexture.Load(uint3(DTid.xy, 0));

		const float2 vec_to_nearest_edge = voronoi_value.xy - pixel_pos;
		const bool is_edge = all(0 == vec_to_nearest_edge.xy);
		const float len_to_nearest_edge = length(vec_to_nearest_edge);
		const float2 dir_to_nearest_edge = (is_edge)? float2(1,0) : normalize(vec_to_nearest_edge);

		
		// デバッグモード.　
		if(1 == VisualizeMode)
		{
			// Workのzにはエッジマスクが格納されているためデバッグ表示.
			OutputTexture[DTid.xy] = voronoi_value.z;
			return;
		}
		if(2 == VisualizeMode)
		{
			// Distance表示.
			OutputTexture[DTid.xy] = saturate(len_to_nearest_edge / 300.0);
			return;
		}
		if(3 == VisualizeMode)
		{
			// シンプルにVoronoiCell地点をサンプリング.
			float4 voronoi_source_color = SourceTexture.Load(uint3(voronoi_value.xy, 0));
			OutputTexture[DTid.xy] = voronoi_source_color;
			return;
		}
		if(4 == VisualizeMode)
		{
			// シンプルにVoronoiCell地点をサンプリング, エッジに近い箇所は元の値を優先.
			float4 voronoi_source_color = SourceTexture.Load(uint3(voronoi_value.xy, 0));
			voronoi_source_color = lerp(source_color, voronoi_source_color, saturate(len_to_nearest_edge / 5.0));
			OutputTexture[DTid.xy] = voronoi_source_color;
			return;
		}
		
		// Voronoi Stroke Test.
		const float k_stroke_max_length = 20;
		const float k_stroke_min_length = 2;
		const float distance_rate = saturate(len_to_nearest_edge / 10.0);
		const float stroke_dir_rate = lerp(0, 1.0, distance_rate);
		const float2 stroke_dir = normalize(lerp(float2(dir_to_nearest_edge.y, -dir_to_nearest_edge.x), dir_to_nearest_edge, stroke_dir_rate));
		float4 edge_stroke_color = SourceTexture.Load(uint3(pixel_pos + stroke_dir * clamp(len_to_nearest_edge, k_stroke_min_length, k_stroke_max_length), 0));
		if(5 == VisualizeMode)
		{
			OutputTexture[DTid.xy] = float4(stroke_dir, 0, 0);
			return;
		}
		
		OutputTexture[DTid.xy] = edge_stroke_color;
		
	}

#endif


// Edge Detection and Output Voronoi Seed.
#if 1 == SHADER_ENTRY_POINT_MODE

	Texture2D SceneDepthTexture;
	uint2 SourceDimensions;
	SamplerState SourceSampler;

	// pos.x, pos.y, edge_mask
	RWTexture2D<float3> OutputTexture;
	uint2 OutputDimensions;

	float DepthEdgeCoef;
	uint  EnableTileCell;

	[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
	void MainCS(
		uint3 Gid	: SV_GroupID,
		uint3 DTid	: SV_DispatchThreadID,
		uint3 GTid	: SV_GroupThreadID,
		uint Gi		: SV_GroupIndex
		)
	{
		// エッジにCellCenterを生成.
		float device_depth = SceneDepthTexture.Load(uint3(DTid.xy, 0)).x;
		// View空間深度変換. ViewUniformBufferを要求する.
		float view_depth = ConvertFromDeviceZ(device_depth);
		float vd0 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(-1, -1), 0)).x);
		float vd1 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(0, -1), 0)).x);
		float vd2 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(1, -1), 0)).x);
		float vd3 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(-1, 0), 0)).x);
		float vd4 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(1, 0), 0)).x);
		float vd5 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(-1, 1), 0)).x);
		float vd6 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(0, 1), 0)).x);
		float vd7 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(1, 1), 0)).x);

		const float depth_raplacian_filter = (vd0+vd1+vd2+vd3+vd4+vd5+vd6+vd7) - (8*view_depth); 

		const float depth_edge_sign = sign(depth_raplacian_filter);
		const float depth_edge_value = step(DepthEdgeCoef * view_depth, abs(depth_raplacian_filter));
		// 深度購買の上端(近景の外側)を採用している.
		//const float depth_edge_mask = saturate(-depth_edge_sign * depth_edge_value);
		// 内側.
		const float depth_edge_mask = saturate(depth_edge_sign * depth_edge_value);
	
		// ほぼ等間隔にCellCenterを生成してみるテスト.
		const int k_cell_size = 10;
		const int2 tile_pos = DTid.xy / k_cell_size;

		// CellCenter判定用位置 : タイル中心固定
		//const int2 k_cell_center_pos = (tile_pos * k_cell_size + int(k_cell_size*0.5));
		// CellCenter判定用位置 : タイル内ランダム位置.
		//const float2 tile_rand = SampleRandomFloat2Float2(tile_pos);
		const float2 tile_rand = SampleRandom(tile_pos);// 対角線方向のみのランダムオフセットになるが, 筆っぽい見た目としてはこちらのほうが好ましいかも.
		const int2 k_cell_center_pos = (tile_pos * k_cell_size + ((k_cell_size - 1) * tile_rand));

		float fixed_tile_seed = 0;
		if(EnableTileCell)
		{
			if(all( DTid.xy == k_cell_center_pos ))
			{
				fixed_tile_seed = 1;
			}
		}
		
		// 固定生成 + デプスエッジ
		OutputTexture[DTid.xy] = float3(0, 0, saturate(fixed_tile_seed + depth_edge_mask));

	}
#endif

// Voronoi JumpFlooding First Pass.
//	WorkBufferには1024以上のピクセル座標を格納するため16bit程度の精度を要求する.
#if 2 == SHADER_ENTRY_POINT_MODE
	// Input Voronoi Work
	//	pos.x, pos.y, edge_mask
	Texture2D VoronoiWorkTexture;
	uint2 VoronoiWorkTextureDimensions;
	SamplerState VoronoiWorkTextureSampler;

	uint IsJumpFloodingFirstPass;
	uint JumpFloodingStepSize;

	// Output Voronoi Work.
	//	pos.x, pos.y, edge_mask
	RWTexture2D<float3> OutputTexture;
	uint2 OutputDimensions;

	[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
	void MainCS(
		uint3 Gid	: SV_GroupID,
		uint3 DTid	: SV_DispatchThreadID,
		uint3 GTid	: SV_GroupThreadID,
		uint Gi		: SV_GroupIndex
		)
	{
		const int2 pixel_pos = DTid.xy;
		const float2 pixel_center = pixel_pos + float2(0.5, 0.5);

		// 中心サンプル.
		const float3 cur_voronoi_value = VoronoiWorkTexture.Load(uint3(pixel_pos, 0)).xyz;
		
		float nearest_distance = 65535;
		// ピクセル中心座標. 0.5オフセットされている中心が格納されている場合に有効, 0,0で無効値扱い.
		float2 nearest_pixel_center = float2(0,0);

		for(int j = -1; j <= 1; ++j)
		{
			for(int i = -1; i <= 1; ++i)
			{
				const int2 sample_pixel_pos = pixel_pos + int2(i, j) * JumpFloodingStepSize;
				// オフセットされたピクセル中心座標.
				const float2 sample_pixel_center = sample_pixel_pos + float2(0.5, 0.5);

				// 範囲外チェック. 入出力同一サイズ仮定.
				if(any(int2(0,0) > sample_pixel_pos) || any(OutputDimensions <= sample_pixel_pos))
					continue;

				const float3 sample_voronoi_value = VoronoiWorkTexture.Load(uint3(sample_pixel_pos, 0)).xyz;

				float2 voronoi_compare_center;
				if(0 != IsJumpFloodingFirstPass)
				{
					// 初回パス. 初回はサンプルピクセル自体の中心座標を値として採用.
					voronoi_compare_center = sample_pixel_center;
					
					// 対象ピクセルの値が非ゼロ(エッジ等)の場合のみ有効シードとして処理する. それ以外はスキップ.
					if(all(0 == sample_voronoi_value))
					{
						continue;
					}
				}
				else
				{
					// 反復パス. Voronoiテクスチャの作業中の値を採用.
					voronoi_compare_center = sample_voronoi_value.xy;
					
					// サンプルピクセルの値は有効であれば 0.5 オフセットされたピクセル中心座標であるため.
					// 0,0 の場合は無効でまだJumpFloodingで確定していないピクセルであるとしてスキップ.
					// 反復パスでは有効なピクセルについてxyが格納されているのでzは見ない.
					if(all(0 == sample_voronoi_value.xy))
						continue;
				}
				

				// 反復中はサンプルピクセルのワークテクスチャ中の値を採用. 誤差対策で改めてピクセル中心座標を計算.
				const float2 voronoi_nearest_center = floor(voronoi_compare_center) + float2(0.5, 0.5);
				
				const float dist = distance(voronoi_nearest_center, pixel_center);
				if(nearest_distance > dist)
				{
					// 最近傍更新.
					nearest_pixel_center = voronoi_nearest_center;
					nearest_distance = dist;
				}
			}
		}
		
		OutputTexture[DTid.xy] = float3(nearest_pixel_center, cur_voronoi_value.z);
	}
#endif


