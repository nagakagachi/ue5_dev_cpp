// PrePostProcessToon.usf

#include "/Engine/Private/Common.ush"

#if !defined(SHADER_ENTRY_POINT_MODE)
#define SHADER_ENTRY_POINT_MODE 0
#endif

#if 0 == SHADER_ENTRY_POINT_MODE

	Texture2D SourceTexture;
	uint2 SourceDimensions;
	SamplerState SourceSampler;

	RWTexture2D<float4> OutputTexture;
	uint2 OutputDimensions;

	uint VisualizeMode;

	float SampleRandom(float2 st) {
		return frac(sin(dot(st.xy,
							 float2(12.9898,78.233)))*43758.5453123);
	}

	[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
	void MainCS(
		uint3 Gid	: SV_GroupID,
		uint3 DTid	: SV_DispatchThreadID,
		uint3 GTid	: SV_GroupThreadID,
		uint Gi		: SV_GroupIndex
		)
	{
		float4 source_color = SourceTexture.Load(uint3(DTid.xy, 0));

		const float2 vec_to_nearest_edge = source_color.xy - (DTid.xy + float2(0.5, 0.5));

		//const float nearest_length = length(vec_to_nearest_edge);
		//const float2 nearest_dir = any(0!=vec_to_nearest_edge)? normalize(vec_to_nearest_edge) : float2(0,0);
		//OutputTexture[DTid.xy] = float4((nearest_dir), pow(saturate(nearest_length / 800.0), 0.75), 0);
		if(1 == VisualizeMode)
		{
			// Workのzにはエッジマスクが格納されているためデバッグ表示.
			OutputTexture[DTid.xy] = source_color.z;
			return;
		}
		// Distance表示.
		float dist_voronoi = distance(source_color.xy, DTid.xy + float2(0.5,0.5));
		OutputTexture[DTid.xy] = pow(saturate(dist_voronoi / 300.0), 0.5);
	}

#endif


// Edge Detection and Output Voronoi Seed.
#if 1 == SHADER_ENTRY_POINT_MODE

	Texture2D SceneDepthTexture;
	uint2 SourceDimensions;
	SamplerState SourceSampler;

	// pos.x, pos.y, edge_mask
	RWTexture2D<float3> OutputTexture;
	uint2 OutputDimensions;

	float DepthEdgeCoef;

	[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
	void MainCS(
		uint3 Gid	: SV_GroupID,
		uint3 DTid	: SV_DispatchThreadID,
		uint3 GTid	: SV_GroupThreadID,
		uint Gi		: SV_GroupIndex
		)
	{
		float device_depth = SceneDepthTexture.Load(uint3(DTid.xy, 0)).x;
		// View空間深度変換. ViewUniformBufferを要求する.
		float view_depth = ConvertFromDeviceZ(device_depth);
		float vd0 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(-1, -1), 0)).x);
		float vd1 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(0, -1), 0)).x);
		float vd2 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(1, -1), 0)).x);
		float vd3 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(-1, 0), 0)).x);
		float vd4 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(1, 0), 0)).x);
		float vd5 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(-1, 1), 0)).x);
		float vd6 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(0, 1), 0)).x);
		float vd7 = ConvertFromDeviceZ(SceneDepthTexture.Load(uint3(DTid.xy + int2(1, 1), 0)).x);

		const float depth_raplacian_filter = (vd0+vd1+vd2+vd3+vd4+vd5+vd6+vd7) - (8*view_depth); 

		const float depth_edge_sign = sign(depth_raplacian_filter);
		const float depth_edge_value = step(DepthEdgeCoef * view_depth, abs(depth_raplacian_filter));
		// 深度購買の上端(近景の外側)を採用している.
		const float depth_edge_mask = saturate(-depth_edge_sign * depth_edge_value);

#if 1
		OutputTexture[DTid.xy] = float3(0, 0, depth_edge_mask);
#else
		// デバッグ用.
		if(DTid.y == 500)
		{
			OutputTexture[DTid.xy] = float3(0, 0, 1);
		}
		else
		{
			OutputTexture[DTid.xy] = float3(0, 0, 0);
		}
#endif
	}
#endif

// Voronoi JumpFlooding First Pass.
#if 2 == SHADER_ENTRY_POINT_MODE
	Texture2D VoronoiWorkTexture;
	uint2 VoronoiWorkTextureDimensions;
	SamplerState VoronoiWorkTextureSampler;

	uint IsJumpFloodingFirstPass;
	uint JumpFloodingStepSize;

	// pos.x, pos.y, edge_mask
	RWTexture2D<float3> OutputTexture;
	uint2 OutputDimensions;

	[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
	void MainCS(
		uint3 Gid	: SV_GroupID,
		uint3 DTid	: SV_DispatchThreadID,
		uint3 GTid	: SV_GroupThreadID,
		uint Gi		: SV_GroupIndex
		)
	{
		const int2 pixel_pos = DTid.xy;
		const float2 pixel_center = pixel_pos + float2(0.5, 0.5);

		// 中心サンプル.
		const float3 cur_voronoi_value = VoronoiWorkTexture.Load(uint3(pixel_pos, 0)).xyz;
		
		float nearest_distance = 65535;
		// ピクセル中心座標. 0.5オフセットされている中心が格納されている場合に有効, 0,0で無効値扱い.
		float2 nearest_pixel_center = float2(0,0);

		for(int j = -1; j <= 1; ++j)
		{
			for(int i = -1; i <= 1; ++i)
			{
				const int2 sample_pixel_pos = pixel_pos + int2(i, j) * JumpFloodingStepSize;
				// オフセットされたピクセル中心座標.
				const float2 sample_pixel_center = sample_pixel_pos + float2(0.5, 0.5);

				// 範囲外チェック. 入出力同一サイズ仮定.
				if(any(int2(0,0) > sample_pixel_pos) || any(OutputDimensions <= sample_pixel_pos))
					continue;

				const float3 sample_voronoi_value = VoronoiWorkTexture.Load(uint3(sample_pixel_pos, 0)).xyz;

				float2 voronoi_compare_center;
				if(0 != IsJumpFloodingFirstPass)
				{
					// 初回パス. 初回はサンプルピクセル自体の中心座標を値として採用.
					voronoi_compare_center = sample_pixel_center;
					
					// 対象ピクセルの値が非ゼロ(エッジ等)の場合のみ有効シードとして処理する. それ以外はスキップ.
					if(all(0 == sample_voronoi_value))
					{
						continue;
					}
				}
				else
				{
					// 反復パス. Voronoiテクスチャの作業中の値を採用.
					voronoi_compare_center = sample_voronoi_value.xy;
					
					// サンプルピクセルの値は有効であれば 0.5 オフセットされたピクセル中心座標であるため.
					// 0,0 の場合は無効でまだJumpFloodingで確定していないピクセルであるとしてスキップ.
					// 反復パスでは有効なピクセルについてxyが格納されているのでzは見ない.
					if(all(0 == sample_voronoi_value.xy))
						continue;
				}
				

				// 反復中はサンプルピクセルのワークテクスチャ中の値を採用. 誤差対策で改めてピクセル中心座標を計算.
				const float2 voronoi_nearest_center = floor(voronoi_compare_center) + float2(0.5, 0.5);
				
				const float dist = distance(voronoi_nearest_center, pixel_center);
				if(nearest_distance > dist)
				{
					// 最近傍更新.
					nearest_pixel_center = voronoi_nearest_center;
					nearest_distance = dist;
				}
			}
		}
		
		OutputTexture[DTid.xy] = float3(nearest_pixel_center, cur_voronoi_value.z);
	}
#endif


