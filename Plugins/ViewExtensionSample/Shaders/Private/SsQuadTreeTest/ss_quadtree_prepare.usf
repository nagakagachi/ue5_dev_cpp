// ss_quadtree_prepare.usf

#include "/Engine/Private/Common.ush"


Texture2D InputTexture;
uint2 InputDimensions;
SamplerState InputSampler;

// globallycoherent は DeviceMemoryBarrierWithGroup で UAVバリアを発行した際に別Groupも含めてキャッシュフラッシュして変更を可視とするために必要.
globallycoherent RWTexture2D<float4> OutputTexture;

uint2 OutputDimensions;


//
// GroupThreadはターゲット解像度の縦横半分のサイズでDispatchされる.
//

groupshared float4 lds_mips0[THREADGROUPSIZE_Y][THREADGROUPSIZE_X * 2];
groupshared float4 lds_mips1[THREADGROUPSIZE_Y][THREADGROUPSIZE_X * 2];

[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
void MainCS(
	uint3 Gid	: SV_GroupID,
	uint3 DTid	: SV_DispatchThreadID,
	uint3 GTid	: SV_GroupThreadID,
	uint Gi		: SV_GroupIndex
	)
{
	const uint2 reso_half = OutputDimensions/2;
	const uint2 sqavg_offset = uint2(0, reso_half.y);// 下段半分で別のMipを作る場合のオフセット.

	
	const uint2 tile_read_lt_pos = Gid.xy * (uint2(THREADGROUPSIZE_X, THREADGROUPSIZE_Y) * 2);
	const uint2 thread_read_2x2_lt_pos = tile_read_lt_pos + GTid.xy*2;
	const uint2 lds_pos = GTid.xy;
	
	// LDSクリア
	{
		// LDSは横方向に2倍サイズなので1Threadが1要素クリア.
		lds_mips0[lds_pos.y][lds_pos.x*2] = float4(0, 0, 0, 0);
		lds_mips0[lds_pos.y][lds_pos.x*2 + 1] = float4(0, 0, 0, 0);
		
		lds_mips1[lds_pos.y][lds_pos.x*2] = float4(0, 0, 0, 0);
		lds_mips1[lds_pos.y][lds_pos.x*2 + 1] = float4(0, 0, 0, 0);
	}
	
	// LDSでの一括計算とUAV書き込みバッチ化.
	//	バッチは log2(numthreads)+1 のMip分. numthreads=16 なら 5. (16,8,4,2,1

	// LDSのMip0セットアップ.
	{
		// UAV読み取り
		const float4 input_00 = InputTexture.Load(int3(thread_read_2x2_lt_pos + uint2(0, 0), 0));
		const float4 input_10 = InputTexture.Load(int3(thread_read_2x2_lt_pos + uint2(1, 0), 0));
		const float4 input_01 = InputTexture.Load(int3(thread_read_2x2_lt_pos + uint2(0, 1), 0));
		const float4 input_11 = InputTexture.Load(int3(thread_read_2x2_lt_pos + uint2(1, 1), 0));

		// LDS書き込み
		// 平均.
		const float4 avg = (input_00 + input_10 + input_01 + input_11) / 4.0;
		lds_mips0[lds_pos.y][lds_pos.x] = avg;

		// 二乗の平均.
		const float4 sqavg = (input_00*input_00 + input_10*input_10 + input_01*input_01 + input_11*input_11) / 4.0;
		lds_mips1[lds_pos.y][lds_pos.x] = sqavg;
		
		// Mip0の書き込み待ち.
		GroupMemoryBarrierWithGroupSync();
	}
	
	uint mip_level = 0;
	
	// Group毎のLDS上で可能な範囲でMip計算.
	mip_level = 0;
	// LOS作業は最上段の一つ下から開始なので THREADGROUPSIZE_X>>1 開始.
	for(uint downsample_region = THREADGROUPSIZE_X>>1; downsample_region >= 1; downsample_region = downsample_region>>1, ++mip_level)
	{
		// 等比級数和で直接Mipのオフセットを計算.
		const float mip_pow_div = pow(0.5, mip_level+1);// +1
		const float mip_offset_mul_next = (mip_pow_div - 1.0)/(0.5 - 1.0);
		const float mip_offset_mul_prev = ((mip_pow_div*2.0) - 1.0)/(0.5 - 1.0);
		// LDS上のMipのオフセット位置. (横方向にMipレイアウト.
		const uint2 cur_lds_offset = uint2(THREADGROUPSIZE_X * mip_offset_mul_next, 0);
		const uint2 pre_lds_offset = uint2(THREADGROUPSIZE_X * mip_offset_mul_prev, 0);
		const uint pre_lds_region = downsample_region << 1; // *2

		// LDS内のMip範囲のみ処理. Barrierのためcontinueはしない.
		if(all(lds_pos < downsample_region))
		{
			const uint2 src_lt = min(lds_pos*2, pre_lds_region - 1) + pre_lds_offset;
			const uint2 dst_pos = lds_pos + cur_lds_offset;

			// avg. 上段.
			lds_mips0[dst_pos.y][dst_pos.x] =
				(lds_mips0[src_lt.y][src_lt.x] + lds_mips0[src_lt.y][src_lt.x+1] + lds_mips0[src_lt.y+1][src_lt.x] + lds_mips0[src_lt.y+1][src_lt.x+1]) /4.0;

			// sqavg. 下段.
			lds_mips1[dst_pos.y][dst_pos.x] =
				(lds_mips1[src_lt.y][src_lt.x] + lds_mips1[src_lt.y][src_lt.x+1] + lds_mips1[src_lt.y+1][src_lt.x] + lds_mips1[src_lt.y+1][src_lt.x+1]) /4.0;
		}
		// GroupThreadバリア
		GroupMemoryBarrierWithGroupSync();
	}
	
	// LDS上に構築した分のMipをバッチ的にUAV書き込み.
	// こちらは読み取りも書き込み先も重複しないためバリアなし.
	mip_level = 0;
	for(uint downsample_region = THREADGROUPSIZE_X; downsample_region >= 1; downsample_region = downsample_region>>1, ++mip_level)
	{
		const uint2 mip_size = max(1, reso_half >> mip_level);
		// 等比級数和で直接Mipのオフセットを計算.
		const float mip_pow_div = pow(0.5, mip_level);
		const float mip_offset_mul_next = ((mip_pow_div) - 1)/(0.5 - 1.0);

		// UAVのこの段階のMip書き込み.
		const uint2 px_pos_in_mip = Gid.xy * (uint2(THREADGROUPSIZE_X, THREADGROUPSIZE_Y) >> (mip_level)) + lds_pos;

		// 書き込み先が現在のMip範囲内のみ処理.
		if(any(px_pos_in_mip >= mip_size))
			continue;
		// LDS内のMip範囲のみ処理.
		if(any(lds_pos >= downsample_region))
			continue;
		
		// UAVの対象Mipの横方向オフセット.
		const uint2 write_uav_mip_offset = uint2(reso_half.x * mip_offset_mul_next, 0);
		// UAVの書き込み先.
		const uint2 write_thread_pos = write_uav_mip_offset + px_pos_in_mip;
		
		// LDS上のMipのオフセット位置. (横方向にMipレイアウト.
		const uint2 cur_lds_offset = uint2(THREADGROUPSIZE_X * mip_offset_mul_next, 0);
		const uint2 px_pos_in_tile = lds_pos + cur_lds_offset;
		// avg. 上段.
		{
			const uint2 write_thread_pos_avg = write_thread_pos;
			OutputTexture[write_thread_pos_avg] = lds_mips0[px_pos_in_tile.y][px_pos_in_tile.x];
		}
		// sqavg. 下段.
		{
			const uint2 write_thread_pos_avg = write_thread_pos + sqavg_offset;
			OutputTexture[write_thread_pos_avg] = lds_mips1[px_pos_in_tile.y][px_pos_in_tile.x];
		}
	}

	// UAV書き込みフラッシュ. globallycoherent指定のUAVであれば他のGroupを含めてGPU全体でキャッシュフラッシュされて変更が可視になる.
	//DeviceMemoryBarrierWithGroupSync();

}





