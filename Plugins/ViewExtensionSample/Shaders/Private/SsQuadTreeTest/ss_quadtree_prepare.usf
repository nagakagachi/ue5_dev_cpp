// ss_quadtree_prepare.usf

#include "/Engine/Private/Common.ush"


// FidelityFX SPD ではgloballycoherentを利用してシングルパス実行しているが,
//	最後の同期のために別途AtomicCounter用RWBufferが必要で若干取り回しがわるいため, 今回はマルチパスとする
//	1Dispatchで 1/ThreadGroupSize までのMipを生成するというシェーダとして実装.

// 入力バッファ. FirstPassのみ利用.
Texture2D InputTexture;
uint2 InputDimensions;

// Mip生成バッファ. SecondPass以降はこのバッファ操作のみになる.
RWTexture2D<float4> OutputTexture;
uint2 OutputDimensions;

//
// GroupThreadはターゲット解像度の縦横半分のサイズに対してDispatchされる.
//

// 固定. 最終的に 32x32 threadで　64x64pxタイルを処理する. 64->1, sync, 64->1 で 64*64=4096px を 1px までシングルパスで縮小.
#define THREADGROUPSIZE 16

groupshared float4 lds_mips0[THREADGROUPSIZE][THREADGROUPSIZE * 2];
groupshared float4 lds_mips1[THREADGROUPSIZE][THREADGROUPSIZE * 2];

// Bit Count. 0b0100 -> 1.
int BitCount32(uint v)
{
	uint count = (v & 0x55555555) + ((v >> 1) & 0x55555555);
	count = (count & 0x33333333) + ((count >> 2) & 0x33333333);
	count = (count & 0x0f0f0f0f) + ((count >> 4) & 0x0f0f0f0f);
	count = (count & 0x00ff00ff) + ((count >> 8) & 0x00ff00ff);
	return (count & 0x0000ffff) + ((count >> 16) & 0x0000ffff);
}
// 最大ビット位置. 0b0100 -> 2
int MostSignificantBit32(uint v)
{
	// v==0 の場合の例外処理は内部ではしない.
	v |= (v >> 1);
	v |= (v >> 2);
	v |= (v >> 4);
	v |= (v >> 8);
	v |= (v >> 16);
	return BitCount32(v) - 1;
}


[numthreads(THREADGROUPSIZE,THREADGROUPSIZE,1)]
void FirstCS(
	uint3 Gid	: SV_GroupID,
	uint3 DTid	: SV_DispatchThreadID,
	uint3 GTid	: SV_GroupThreadID,
	uint Gi		: SV_GroupIndex
	)
{
	// ThreadGroup Tileのサイズ.
	const int k_tile_max_mip_count = MostSignificantBit32(THREADGROUPSIZE) + 1;
	const uint2 reso_half = OutputDimensions/2;
	const uint2 sqavg_offset = uint2(0, reso_half.y);// 下段半分で別のMipを作る場合のオフセット.

	const uint2 tile_read_lt_pos = Gid.xy * (uint2(THREADGROUPSIZE, THREADGROUPSIZE) * 2);
	const uint2 thread_read_2x2_lt_pos = tile_read_lt_pos + GTid.xy*2;
	const uint2 lds_pos = GTid.xy;
	
	// LDSクリア
	{
		// LDSは横方向に2倍サイズなので1Threadが1要素クリア.
		lds_mips0[lds_pos.y][lds_pos.x*2] = float4(0, 0, 0, 0);
		lds_mips0[lds_pos.y][lds_pos.x*2 + 1] = float4(0, 0, 0, 0);
		
		lds_mips1[lds_pos.y][lds_pos.x*2] = float4(0, 0, 0, 0);
		lds_mips1[lds_pos.y][lds_pos.x*2 + 1] = float4(0, 0, 0, 0);
	}
	
	// LDSでの一括計算とUAV書き込みバッチ化.
	//	バッチは log2(numthreads)+1 のMip分. numthreads=16 なら 5. (16,8,4,2,1

	// LDSのMip0セットアップ.
	{
		// UAV読み取り
		const float4 input_00 = InputTexture.Load(int3(thread_read_2x2_lt_pos + uint2(0, 0), 0));
		const float4 input_10 = InputTexture.Load(int3(thread_read_2x2_lt_pos + uint2(1, 0), 0));
		const float4 input_01 = InputTexture.Load(int3(thread_read_2x2_lt_pos + uint2(0, 1), 0));
		const float4 input_11 = InputTexture.Load(int3(thread_read_2x2_lt_pos + uint2(1, 1), 0));

		// LDS書き込み
		// 平均.
		lds_mips0[lds_pos.y][lds_pos.x] = (input_00 + input_10 + input_01 + input_11) * 0.25;

		// 二乗の平均.
		lds_mips1[lds_pos.y][lds_pos.x] = (input_00*input_00 + input_10*input_10 + input_01*input_01 + input_11*input_11) * 0.25;
	}
	
	// Group毎のLDS上で可能な範囲でMip計算.
	// LOS作業は最上段の一つ下から開始なので 1 開始.
	for(uint mip_i = 1; mip_i < k_tile_max_mip_count; ++mip_i)
	{
		const uint tile_mip_size = 1 << (k_tile_max_mip_count-1 - mip_i);
		const uint pre_tile_mip_size = tile_mip_size << 1; // *2
		
		// 等比級数和で直接Mipのオフセットを計算.
		const float mip_pow_div = pow(0.5, mip_i);
		// LDS上のMipのオフセット位置. (横方向にMipレイアウト.
		const uint2 cur_lds_offset = uint2(THREADGROUPSIZE * (mip_pow_div - 1.0)/(0.5 - 1.0), 0);
		const uint2 pre_lds_offset = uint2(THREADGROUPSIZE * ((mip_pow_div*2.0) - 1.0)/(0.5 - 1.0), 0);

		// 前のMipの他のThread書き込み待ち.
		GroupMemoryBarrierWithGroupSync();
		
		// LDS内のMip範囲のみ処理.
		if(any(lds_pos >= tile_mip_size))
			continue;

		const uint2 src_lt = min(lds_pos*2, pre_tile_mip_size - 1) + pre_lds_offset;
		const uint2 dst_pos = lds_pos + cur_lds_offset;

		// avg. 上段.
		lds_mips0[dst_pos.y][dst_pos.x] =
			(lds_mips0[src_lt.y][src_lt.x] + lds_mips0[src_lt.y][src_lt.x+1] + lds_mips0[src_lt.y+1][src_lt.x] + lds_mips0[src_lt.y+1][src_lt.x+1]) /4.0;

		// sqavg. 下段.
		lds_mips1[dst_pos.y][dst_pos.x] =
			(lds_mips1[src_lt.y][src_lt.x] + lds_mips1[src_lt.y][src_lt.x+1] + lds_mips1[src_lt.y+1][src_lt.x] + lds_mips1[src_lt.y+1][src_lt.x+1]) /4.0;
	}
	
	// LDS上に構築した分のMipをバッチ的にUAV書き込み.
	// こちらは読み取りも書き込み先も重複しないためバリアなし.
	for(uint mip_i = 0; mip_i < k_tile_max_mip_count; ++mip_i)
	{
		const uint tile_mip_size = 1 << (k_tile_max_mip_count-1 - mip_i);
		
		const uint2 mip_size = max(1, reso_half >> mip_i);
		// 等比級数和で直接Mipのオフセットを計算.
		const float mip_pow_div = pow(0.5, mip_i);
		const float mip_offset_mul_next = ((mip_pow_div) - 1)/(0.5 - 1.0);

		// UAVのこの段階のMip書き込み.
		const uint2 px_pos_in_mip = Gid.xy * (uint2(THREADGROUPSIZE, THREADGROUPSIZE) >> (mip_i)) + lds_pos;

		// 書き込み先が現在のMip範囲内のみ処理, LDS内のMip範囲のみ処理.
		if(any(px_pos_in_mip >= mip_size) || any(lds_pos >= tile_mip_size))
			continue;
		
		// UAVの対象Mipの横方向オフセット.
		const uint2 write_uav_mip_offset = uint2(reso_half.x * mip_offset_mul_next, 0);
		// UAVの書き込み先.
		const uint2 write_thread_pos = write_uav_mip_offset + px_pos_in_mip;
		
		// LDS上のMipのオフセット位置. (横方向にMipレイアウト.
		const uint2 cur_lds_offset = uint2(THREADGROUPSIZE * mip_offset_mul_next, 0);
		const uint2 px_pos_in_tile = lds_pos + cur_lds_offset;
		// avg. 上段.
		{
			const uint2 write_thread_pos_avg = write_thread_pos;
			OutputTexture[write_thread_pos_avg] = lds_mips0[px_pos_in_tile.y][px_pos_in_tile.x];
		}
		// sqavg. 下段.
		{
			const uint2 write_thread_pos_avg = write_thread_pos + sqavg_offset;
			OutputTexture[write_thread_pos_avg] = lds_mips1[px_pos_in_tile.y][px_pos_in_tile.x];
		}
	}
}





