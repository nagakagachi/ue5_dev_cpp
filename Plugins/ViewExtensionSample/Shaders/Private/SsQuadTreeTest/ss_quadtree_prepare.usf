// ss_quadtree_prepare.usf

#include "/Engine/Private/Common.ush"

#include "single_plane_mip_util.ush"

// FidelityFX SPD ではgloballycoherentを利用してシングルパス実行しているが,
//	最後の同期のために別途AtomicCounter用RWBufferが必要で若干取り回しがわるいため, 今回はマルチパスとする
//	1Dispatchで 1/ThreadGroupSize までのMipを生成するというシェーダとして実装.

// 入力バッファ. FirstPassのみ利用.
Texture2D InputTexture;
uint2 InputDimensions;

// Mip生成バッファ. SecondPass以降はこのバッファ操作のみになる.
RWTexture2D<float4> OutputTexture;
uint2 OutputDimensions;

//
// GroupThreadはターゲット解像度の縦横半分のサイズに対してDispatchされる.
//

// 固定. 1/THREADGROUPSIZE までのMip生成をするPass.
// 初回のみ入力テクスチャ読み取りのためFirstCS, それ以降は必要な回数だけ SecondCS を実行することで完全なMipChainを一つのテクスチャ上に横にレイアウト生成する.
// 平均と二乗平均を同時計算するためにSharedMemoryサイズ制限でスレッド数も制限される.
#define THREADGROUPSIZE 32
groupshared float4 lds_mips[THREADGROUPSIZE][THREADGROUPSIZE * 2];


// LDSにセットアップした処理対象範囲の最小Mipを元にLOD上でTile上限Mipを生成し, UAVに書き出す.
// ... 32 16 8 4 2 1 ...
void GenerateLdsMipAndWriteUavCore(
	uint2 max_mip_resolution,
	uint2 write_uav_offset,
	uint start_mip_index,
	uint work_mip_count,
	uint2 tile_index,
	uint2 pos_in_tile
)
{
	const int k_tile_max_mip_count = MostSignificantBit32(THREADGROUPSIZE) + 1;
	
	// Group毎のLDS上で可能な範囲でMip計算.
	// LOS作業は最上段の一つ下から開始なので 1 開始.
	for(uint mip_i = 1; mip_i < work_mip_count; ++mip_i)
	{
		const uint tile_mip_size = 1 << (k_tile_max_mip_count-1 - mip_i);// ここはwork_mip_countは誤り, k_tile_max_mip_countが正しい.
		
		const uint pre_tile_mip_size = tile_mip_size << 1; // *2
		const uint2 cur_lds_offset = CalcSinglePlaneMipOffsetX(THREADGROUPSIZE, mip_i);
		const uint2 pre_lds_offset = CalcSinglePlaneMipOffsetX(THREADGROUPSIZE, mip_i-1);
		
		// 前のMipの他のThread書き込み待ち.
		GroupMemoryBarrierWithGroupSync();
		
		// LDS内のMip範囲のみ処理.
		if(any(pos_in_tile >= tile_mip_size))
			continue;

		const uint2 src_lt = min(pos_in_tile*2, pre_tile_mip_size - 1) + pre_lds_offset;
		const uint2 dst_pos = pos_in_tile + cur_lds_offset;

		lds_mips[dst_pos.y][dst_pos.x] =
			(lds_mips[src_lt.y][src_lt.x] + lds_mips[src_lt.y][src_lt.x+1] + lds_mips[src_lt.y+1][src_lt.x] + lds_mips[src_lt.y+1][src_lt.x+1]) * 0.25;
	}
	
	// LDS上に構築した分のMipをバッチ的にUAV書き込み.
	// こちらは読み取りも書き込み先も重複しないためバリアなし.
	for(uint mip_i = 0; mip_i < work_mip_count; ++mip_i)
	{
		const uint uav_mip_index = start_mip_index + mip_i;
		
		const uint tile_mip_size = 1 << (k_tile_max_mip_count-1 - mip_i);// ここはwork_mip_countは誤り, k_tile_max_mip_countが正しい.
		const uint2 uav_mip_size = CalcSinglePlaneMipResolution(max_mip_resolution, uav_mip_index);
		
		// UAVのこの段階のMip書き込み.
		const uint2 px_pos_in_mip = tile_index * (uint2(THREADGROUPSIZE, THREADGROUPSIZE) >> (mip_i)) + pos_in_tile;
		
		// 書き込み先が現在のMip範囲内のみ処理.
		//	LDS内のMip範囲制限は不要. むしろ.
		if(any(px_pos_in_mip >= uav_mip_size) || any(pos_in_tile >= tile_mip_size))
			continue;
		
		// UAVの対象Mipの横方向オフセット.
		const uint2 write_uav_mip_offset = CalcSinglePlaneMipOffsetX(max_mip_resolution.x, uav_mip_index);
		// UAVの書き込み先.
		const uint2 write_thread_pos = write_uav_mip_offset + px_pos_in_mip;
		
		// LDS上のMipのオフセット位置. (横方向にMipレイアウト.
		const uint2 cur_lds_offset = CalcSinglePlaneMipOffsetX(THREADGROUPSIZE, mip_i);
		const uint2 px_pos_in_tile = pos_in_tile + cur_lds_offset;
		
		const uint2 write_thread_pos_avg = write_thread_pos + write_uav_offset;
		
		{
			OutputTexture[write_thread_pos_avg] = lds_mips[px_pos_in_tile.y][px_pos_in_tile.x];
		}
	}
}


[numthreads(THREADGROUPSIZE,THREADGROUPSIZE,1)]
void FirstCS(
	uint3 Gid	: SV_GroupID,
	uint3 DTid	: SV_DispatchThreadID,
	uint3 GTid	: SV_GroupThreadID,
	uint Gi		: SV_GroupIndex
	)
{
	// ThreadGroup Tileのサイズ.
	const int k_tile_max_mip_count = MostSignificantBit32(THREADGROUPSIZE) + 1;
	const uint2 reso_half = OutputDimensions/2;

	const uint start_mip_index = 0;// FirstPassは0から.
	const uint2 setup_read_offset = uint2(0, 0);// 入力テクスチャ全域を読み取るので 0,0 起点.

	const uint max_mip_count = CalcSinglePlaneMipCount(reso_half, start_mip_index);
	const uint work_mip_count = min(k_tile_max_mip_count, max_mip_count);
	if(0 >= work_mip_count)
		return;

	const uint2 lds_pos = GTid.xy;
	
	// LDSのMip1以降の領域をクリア.
	{
		// LDSは横方向に2倍サイズなので1Threadが1要素クリア.
		lds_mips[lds_pos.y][lds_pos.x*2] = float4(0, 0, 0, 0);
		lds_mips[lds_pos.y][lds_pos.x*2 + 1] = float4(0, 0, 0, 0);
	}
	
	const uint2 tile_read_lt_pos = Gid.xy * (uint2(THREADGROUPSIZE, THREADGROUPSIZE) * 2);
	const uint2 thread_read_2x2_lt_pos = setup_read_offset + tile_read_lt_pos + GTid.xy*2;

	// 上段 平均.
	{
		const uint2 read_uav_offset = uint2(0, 0);
		const uint2 write_uav_offset = uint2(0, 0);
		
		// LDSの開始Mipセットアップ.
		{
			// 入力テクスチャ読み込み.
			const float4 input_00 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(0, 0), 0));
			const float4 input_10 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(1, 0), 0));
			const float4 input_01 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(0, 1), 0));
			const float4 input_11 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(1, 1), 0));

			// LDS書き込み
			// 平均.
			lds_mips[lds_pos.y][lds_pos.x] = (input_00 + input_10 + input_01 + input_11) * 0.25;
		}
		// LDS利用したTile範囲Mip生成とUAV書き出し.
		GenerateLdsMipAndWriteUavCore(
			reso_half,
			write_uav_offset,
			start_mip_index,
			work_mip_count,
			Gid.xy,
			lds_pos
		);
	}
	// 下段.
	{
		const uint2 read_uav_offset = uint2(0, 0);// FirstPassはオリジナルピクセルを読み取るためオフセットしない.
		const uint2 write_uav_offset = uint2(0, reso_half.y);
		
		// LDSの開始Mipセットアップ.
		{
#if 0
			// 二乗の平均.
			{
				// 入力テクスチャ読み込み.
				const float4 input_00 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(0, 0), 0));
				const float4 input_10 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(1, 0), 0));
				const float4 input_01 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(0, 1), 0));
				const float4 input_11 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(1, 1), 0));

				// LDS書き込み
				// 二乗の平均.
				lds_mips[lds_pos.y][lds_pos.x] = (input_00*input_00 + input_10*input_10 + input_01*input_01 + input_11*input_11) * 0.25;
			}
#else
			// エッジ.
			{
				// 入力テクスチャ読み込み.
				const float4 input_00 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(-1, -1), 0));
				const float4 input_10 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(0, -1), 0));
				const float4 input_20 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(1, -1), 0));
				const float4 input_30 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(2, -1), 0));
				
				const float4 input_01 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(-1, 0), 0));
				const float4 input_11 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(0, 0), 0));
				const float4 input_21 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(1, 0), 0));
				const float4 input_31 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(2, 0), 0));

				const float4 input_02 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(-1, 1), 0));
				const float4 input_12 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(0, 1), 0));
				const float4 input_22 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(1, 1), 0));
				const float4 input_32 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(2, 1), 0));
				
				const float4 input_03 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(-1, 2), 0));
				const float4 input_13 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(0, 2), 0));
				const float4 input_23 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(1, 2), 0));
				const float4 input_33 = InputTexture.Load(int3(read_uav_offset + thread_read_2x2_lt_pos + int2(2, 2), 0));


				float4 laplacian0 = abs( (input_00 + input_10 + input_20 + input_01 + input_21 + input_02 + input_12 + input_22) - 8.0*input_11);
				float4 laplacian1 = abs( (input_10 + input_20 + input_30 + input_11 + input_31 + input_12 + input_22 + input_32) - 8.0*input_21);
				float4 laplacian2 = abs( (input_01 + input_11 + input_21 + input_02 + input_22 + input_03 + input_13 + input_23) - 8.0*input_12);
				float4 laplacian3 = abs( (input_11 + input_21 + input_31 + input_12 + input_32 + input_13 + input_23 + input_33) - 8.0*input_22);

				
				float laplacian_scalar0 = dot(laplacian0, float4(1,1,1,1));
				float laplacian_scalar1 = dot(laplacian1, float4(1,1,1,1));
				float laplacian_scalar2 = dot(laplacian2, float4(1,1,1,1));
				float laplacian_scalar3 = dot(laplacian3, float4(1,1,1,1));

				float laplacian_scalar = max(max(laplacian_scalar0, laplacian_scalar1), max(laplacian_scalar2, laplacian_scalar3));
				
				float edge = (0.25 < laplacian_scalar)? 1.0 : 0.0;
				
				// LDS書き込み
				lds_mips[lds_pos.y][lds_pos.x] = edge;
			}
#endif
		}
		// LDS利用したTile範囲Mip生成とUAV書き出し.
		GenerateLdsMipAndWriteUavCore(
			reso_half,
			write_uav_offset,
			start_mip_index,
			work_mip_count,
			Gid.xy,
			lds_pos
		);
	}
}

// FirstPassの後のUAV上での残りのMip生成.
//	TODO. UAVから継続するための前の最大Mipを読み取る際に境界でClampしないと黒等が入ってきて適切な平均にならない問題が残っている.
[numthreads(THREADGROUPSIZE,THREADGROUPSIZE,1)]
void SecondCS(
	uint3 Gid	: SV_GroupID,
	uint3 DTid	: SV_DispatchThreadID,
	uint3 GTid	: SV_GroupThreadID,
	uint Gi		: SV_GroupIndex
	)
{
	// ThreadGroup Tileのサイズ.
	const int k_tile_max_mip_count = MostSignificantBit32(THREADGROUPSIZE) + 1;
	const uint2 reso_half = OutputDimensions/2;

	const uint start_mip_index = k_tile_max_mip_count;// SecondPassはTile分の縮小後のMipから.
	const uint2 setup_read_offset = CalcSinglePlaneMipOffsetX(reso_half.x, start_mip_index-1);// FirstPassが書き込んだ最後のMipであるstart_mip_index-1から読み取る.
	
	const uint max_mip_count = CalcSinglePlaneMipCount(reso_half, start_mip_index);
	const uint work_mip_count = min(k_tile_max_mip_count, max_mip_count);
	if(0 >= work_mip_count)
		return;
	
	const uint2 lds_pos = GTid.xy;
	
	// LDSのMip1以降の領域をクリア.
	{
		// LDSは横方向に2倍サイズなので1Threadが1要素クリア.
		lds_mips[lds_pos.y][lds_pos.x*2] = float4(0, 0, 0, 0);
		lds_mips[lds_pos.y][lds_pos.x*2 + 1] = float4(0, 0, 0, 0);
	}

	const uint2 tile_read_lt_pos = Gid.xy * (uint2(THREADGROUPSIZE, THREADGROUPSIZE) * 2);
	const uint2 thread_read_2x2_lt_pos = setup_read_offset + tile_read_lt_pos + GTid.xy*2;
	
	// 上段.
	{
		const uint2 read_uav_offset = uint2(0, 0);
		const uint2 write_uav_offset = uint2(0, 0);
		
		// LDSの開始Mipセットアップ.
		{
			// 前Passで書き込まれたOutputTextureの最大Mipを読み取って続きを計算する.
			const float4 input_00 = OutputTexture[read_uav_offset + thread_read_2x2_lt_pos + uint2(0, 0)];
			const float4 input_10 = OutputTexture[read_uav_offset + thread_read_2x2_lt_pos + uint2(1, 0)];
			const float4 input_01 = OutputTexture[read_uav_offset + thread_read_2x2_lt_pos + uint2(0, 1)];
			const float4 input_11 = OutputTexture[read_uav_offset + thread_read_2x2_lt_pos + uint2(1, 1)];

			// LDS書き込み
			// 平均.
			lds_mips[lds_pos.y][lds_pos.x] = (input_00 + input_10 + input_01 + input_11) * 0.25;
		}
		// LDS利用したTile範囲Mip生成とUAV書き出し.
		GenerateLdsMipAndWriteUavCore(
			reso_half,
			write_uav_offset,
			start_mip_index,
			work_mip_count,
			Gid.xy,
			lds_pos
		);
	}

	// 下段.
	{
		const uint2 read_uav_offset = uint2(0, reso_half.y);// SecondPassでは前Passの書き込んだUAV位置を読み取るため書き込みと同じ縦方向オフセットする.
		const uint2 write_uav_offset = uint2(0, reso_half.y);
		
		// LDSの開始Mipセットアップ.
		{
			// 前Passで書き込まれたOutputTextureの最大Mipを読み取って続きを計算する.
			const float4 input_00 = OutputTexture[read_uav_offset + thread_read_2x2_lt_pos + uint2(0, 0)];
			const float4 input_10 = OutputTexture[read_uav_offset + thread_read_2x2_lt_pos + uint2(1, 0)];
			const float4 input_01 = OutputTexture[read_uav_offset + thread_read_2x2_lt_pos + uint2(0, 1)];
			const float4 input_11 = OutputTexture[read_uav_offset + thread_read_2x2_lt_pos + uint2(1, 1)];

			// LDS書き込み
			// 平均.
			lds_mips[lds_pos.y][lds_pos.x] = (input_00 + input_10 + input_01 + input_11) * 0.25;
		}
		// LDS利用したTile範囲Mip生成とUAV書き出し.
		GenerateLdsMipAndWriteUavCore(
			reso_half,
			write_uav_offset,
			start_mip_index,
			work_mip_count,
			Gid.xy,
			lds_pos
		);
	}
}




