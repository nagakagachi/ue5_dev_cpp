// @author: @nagakagachi
// ss_quadtree_prepare.usf

#include "/Engine/Private/Common.ush"

#include "single_plane_mip_util.ush"

Texture2D InputTexture;
uint2 InputDimensions;
SamplerState InputSampler;

uint DisplayMipLevel;

struct VsOutput
{
	float4 UVAndScreenPos : TEXCOORD0;
	float4 OutPosition : SV_POSITION;// メンバの順序をVS側の送出の順序をあわせないとPSO生成時にエラーになる
};

struct PsOut
{
	float4 color : SV_TARGET0;
};

uint4 CalcSinglePlaneMipOffsetAndSize(uint2 base_mip_reso, uint mip_level)
{
	const uint2 mip_offset = CalcSinglePlaneMipOffsetX(base_mip_reso, mip_level);
	const uint2 mip_resolution = CalcSinglePlaneMipResolution(base_mip_reso, mip_level);
	return uint4(mip_offset.x, mip_offset.y, mip_resolution.x, mip_resolution.y);
}

PsOut MainPS(VsOutput input)
{
	PsOut output = (PsOut)0;

	const float2 pixel_size = 1.0 / (float2)InputDimensions;
	const uint2 base_mip_resolution = InputDimensions/2;// 半解像度以降のMipを格納しているのでベースは 1/2.
	const int mip_count = CalcSinglePlaneMipCount(base_mip_resolution, 0);

	const float2 ss_uv = input.UVAndScreenPos.xy;
#if 0
	// エッジ付近のみ解像度を高く表示するテスト.
	const uint4 mip0_offset_size = CalcSinglePlaneMipOffsetAndSize(base_mip_resolution, 0);
	const float4 color_avg0 = InputTexture.Load(int3( (ss_uv * mip0_offset_size.zw) + mip0_offset_size.xy, 0 ));
	const float4 color_sub_avg0 = InputTexture.Load(int3( (ss_uv * mip0_offset_size.zw) + mip0_offset_size.xy + uint2(0, base_mip_resolution.y), 0 ));
	
	const uint search_mip_max = mip_count;
	int display_mip = 0;
	for(int mip_level = 0; mip_level <  search_mip_max-1; ++mip_level)
	{
		const int mip = search_mip_max - 1 - mip_level;

		const uint4 parent_mip_offset_size = CalcSinglePlaneMipOffsetAndSize(base_mip_resolution, mip);
		const float4 parent_value = InputTexture.Load(int3( (ss_uv * parent_mip_offset_size.zw) + parent_mip_offset_size.xy + uint2(0, base_mip_resolution.y), 0 ));

		// このMipの1ピクセルの総面積からエッジ総数を計算.
		const float parent_mip_total = parent_value.x * (1 << (mip*2));
		if(0 == parent_mip_total)
		{
			display_mip = mip;
			break;
		}
	}
	
	const float display_mip_rate = float(display_mip)/(mip_count-1);
	
	float4 out_color = float4(display_mip_rate, display_mip_rate, display_mip_rate, 1);

	if(0.1 < ss_uv.x)
	{
		const uint4 debug_mip_offset_size = CalcSinglePlaneMipOffsetAndSize(base_mip_resolution, clamp(display_mip, 0, mip_count-1));
		
		const float4 debug_color = InputTexture.Load(int3( (ss_uv * debug_mip_offset_size.zw) + debug_mip_offset_size.xy + uint2(0, 0), 0 ));
		out_color = float4(debug_color.xyz, 1.0);
	}
	
	output.color = out_color;

#else
	// デバッグ表示.
	const uint req_mip_level = DisplayMipLevel;
	const uint mip_level = clamp(req_mip_level, 0, mip_count-1);
	const uint2 mip_offset = CalcSinglePlaneMipOffsetX(base_mip_resolution, mip_level);
	const uint2 mip_resolution = CalcSinglePlaneMipResolution(base_mip_resolution, mip_level);
	
	const float2 mip_local_px_pos = clamp(ss_uv * mip_resolution, 0, mip_resolution-1);
	
	const float4 color_avg = InputTexture.Load(int3( mip_local_px_pos + mip_offset, 0 ));
	const float4 color_sub_avg = InputTexture.Load(int3( mip_local_px_pos + mip_offset + uint2(0, base_mip_resolution.y), 0 ));
	
	float4 out_color = color_avg;
	if(0.5 < ss_uv.x)
	{
		out_color = color_sub_avg;
	}
	output.color = out_color;
#endif
	
	return output;
}
